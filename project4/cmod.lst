   1               		.file	"cmod.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupIOPins
  12               	setupIOPins:
  13               	.LFB1:
  14               		.file 1 "cmod.c"
   1:cmod.c        **** #include "cmod.h"
   2:cmod.c        **** #include "oi.h"
   3:cmod.c        **** #include "timer.h"
   4:cmod.c        **** 
   5:cmod.c        **** void initializeCommandModule(void){
   6:cmod.c        ****   // Disable interrupts. ("Clear interrupt bit")
   7:cmod.c        ****   cli();
   8:cmod.c        **** 
   9:cmod.c        ****   // One-time setup operations.
  10:cmod.c        ****   setupIOPins();
  11:cmod.c        ****   setupTimer();
  12:cmod.c        ****   setupSerialPort();
  13:cmod.c        **** 
  14:cmod.c        ****   // Enable interrupts. ("Set interrupt bit")
  15:cmod.c        ****   sei();
  16:cmod.c        **** }
  17:cmod.c        **** 
  18:cmod.c        **** void setupIOPins(void) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  19:cmod.c        ****   // Set I/O pins
  20:cmod.c        ****   DDRB  = 0x10;
  21               		.loc 1 20 0
  22 0000 80E1      		ldi r24,lo8(16)
  23 0002 84B9      		out 0x4,r24
  21:cmod.c        ****   PORTB = 0xCF;
  24               		.loc 1 21 0
  25 0004 8FEC      		ldi r24,lo8(-49)
  26 0006 85B9      		out 0x5,r24
  22:cmod.c        ****   DDRC  = 0x00;
  27               		.loc 1 22 0
  28 0008 17B8      		out 0x7,__zero_reg__
  23:cmod.c        ****   PORTC = 0xFF;
  29               		.loc 1 23 0
  30 000a 8FEF      		ldi r24,lo8(-1)
  31 000c 88B9      		out 0x8,r24
  24:cmod.c        ****   DDRD  = 0xE6;
  32               		.loc 1 24 0
  33 000e 86EE      		ldi r24,lo8(-26)
  34 0010 8AB9      		out 0xa,r24
  25:cmod.c        ****   PORTD = 0x7D;
  35               		.loc 1 25 0
  36 0012 8DE7      		ldi r24,lo8(125)
  37 0014 8BB9      		out 0xb,r24
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE1:
  42               	.global	setupSerialPort
  44               	setupSerialPort:
  45               	.LFB2:
  26:cmod.c        **** }
  27:cmod.c        **** 
  28:cmod.c        **** void setupSerialPort(void) {
  46               		.loc 1 28 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  29:cmod.c        ****   // Set the transmission speed to 57600 baud, which is what the Create expects,
  30:cmod.c        ****   // unless we tell it otherwise.
  31:cmod.c        ****   UBRR0 = 19;
  52               		.loc 1 31 0
  53 0018 83E1      		ldi r24,lo8(19)
  54 001a 90E0      		ldi r25,0
  55 001c 9093 C500 		sts 196+1,r25
  56 0020 8093 C400 		sts 196,r24
  32:cmod.c        ****   
  33:cmod.c        ****   // Enable both transmit and receive.
  34:cmod.c        ****   UCSR0B = (_BV(RXCIE0) | _BV(TXEN0) | _BV(RXEN0));
  57               		.loc 1 34 0
  58 0024 88E9      		ldi r24,lo8(-104)
  59 0026 8093 C100 		sts 193,r24
  35:cmod.c        ****     // UCSR0B = 0x18;
  36:cmod.c        ****   
  37:cmod.c        ****   // Set 8-bit data.
  38:cmod.c        ****   UCSR0C = (_BV(UCSZ00) | _BV(UCSZ01));
  60               		.loc 1 38 0
  61 002a 86E0      		ldi r24,lo8(6)
  62 002c 8093 C200 		sts 194,r24
  39:cmod.c        ****     // UCSR0C = 0x06;
  40:cmod.c        **** 
  41:cmod.c        ****   //Turn on interupts
  42:cmod.c        ****   sei();
  63               		.loc 1 42 0
  64               	/* #APP */
  65               	 ;  42 "cmod.c" 1
  66 0030 7894      		sei
  67               	 ;  0 "" 2
  68               	/* #NOAPP */
  69 0032 0895      		ret
  70               		.cfi_endproc
  71               	.LFE2:
  73               	.global	initializeCommandModule
  75               	initializeCommandModule:
  76               	.LFB0:
   5:cmod.c        **** void initializeCommandModule(void){
  77               		.loc 1 5 0
  78               		.cfi_startproc
  79               	/* prologue: function */
  80               	/* frame size = 0 */
  81               	/* stack size = 0 */
  82               	.L__stack_usage = 0
   7:cmod.c        ****   cli();
  83               		.loc 1 7 0
  84               	/* #APP */
  85               	 ;  7 "cmod.c" 1
  86 0034 F894      		cli
  87               	 ;  0 "" 2
  10:cmod.c        ****   setupIOPins();
  88               		.loc 1 10 0
  89               	/* #NOAPP */
  90 0036 0E94 0000 		call setupIOPins
  91               	.LVL0:
  11:cmod.c        ****   setupTimer();
  92               		.loc 1 11 0
  93 003a 0E94 0000 		call setupTimer
  94               	.LVL1:
  12:cmod.c        ****   setupSerialPort();
  95               		.loc 1 12 0
  96 003e 0E94 0000 		call setupSerialPort
  97               	.LVL2:
  15:cmod.c        ****   sei();
  98               		.loc 1 15 0
  99               	/* #APP */
 100               	 ;  15 "cmod.c" 1
 101 0042 7894      		sei
 102               	 ;  0 "" 2
 103               	/* #NOAPP */
 104 0044 0895      		ret
 105               		.cfi_endproc
 106               	.LFE0:
 108               	.global	setSerialDestination
 110               	setSerialDestination:
 111               	.LFB3:
  43:cmod.c        **** }
  44:cmod.c        **** 
  45:cmod.c        **** void setSerialDestination(uint8_t dest) {
 112               		.loc 1 45 0
 113               		.cfi_startproc
 114               	.LVL3:
 115 0046 CF93      		push r28
 116               	.LCFI0:
 117               		.cfi_def_cfa_offset 3
 118               		.cfi_offset 28, -2
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 1 */
 122               	.L__stack_usage = 1
 123 0048 C82F      		mov r28,r24
  46:cmod.c        **** 	//set serial port for byteTx/Rx
  47:cmod.c        **** 	//make sure pending bytes have been set
  48:cmod.c        **** 	delayMs(10);
 124               		.loc 1 48 0
 125 004a 8AE0      		ldi r24,lo8(10)
 126 004c 90E0      		ldi r25,0
 127               	.LVL4:
 128 004e 0E94 0000 		call delayMs
 129               	.LVL5:
  49:cmod.c        **** 
  50:cmod.c        **** 	//configure the port
  51:cmod.c        **** 	if (dest == SERIAL_CREATE) {
 130               		.loc 1 51 0
 131 0052 C130      		cpi r28,lo8(1)
 132 0054 01F4      		brne .L5
  52:cmod.c        **** 		PORTB &= ~0x10;
 133               		.loc 1 52 0
 134 0056 2C98      		cbi 0x5,4
 135 0058 00C0      		rjmp .L6
 136               	.L5:
  53:cmod.c        **** 	} else {
  54:cmod.c        **** 		PORTB |= 0x10;
 137               		.loc 1 54 0
 138 005a 2C9A      		sbi 0x5,4
 139               	.L6:
  55:cmod.c        **** 	}
  56:cmod.c        **** 
  57:cmod.c        **** 	//wait again to make sure the change has occured properly
  58:cmod.c        **** 	delayMs(10);
 140               		.loc 1 58 0
 141 005c 8AE0      		ldi r24,lo8(10)
 142 005e 90E0      		ldi r25,0
 143               	/* epilogue start */
  59:cmod.c        **** }
 144               		.loc 1 59 0
 145 0060 CF91      		pop r28
 146               	.LVL6:
  58:cmod.c        **** 	delayMs(10);
 147               		.loc 1 58 0
 148 0062 0C94 0000 		jmp delayMs
 149               	.LVL7:
 150               		.cfi_endproc
 151               	.LFE3:
 153               	.global	flushRx
 155               	flushRx:
 156               	.LFB4:
  60:cmod.c        **** 
  61:cmod.c        **** // Flush serial buffer
  62:cmod.c        **** void flushRx() {
 157               		.loc 1 62 0
 158               		.cfi_startproc
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 0 */
 162               	.L__stack_usage = 0
 163               	.L9:
  63:cmod.c        ****   uint8_t i;
  64:cmod.c        ****   while (UCSR0A & 0x80) {
 164               		.loc 1 64 0 discriminator 1
 165 0066 8091 C000 		lds r24,192
 166 006a 87FF      		sbrs r24,7
 167 006c 00C0      		rjmp .L11
  65:cmod.c        ****     i = UDR0;
 168               		.loc 1 65 0
 169 006e 8091 C600 		lds r24,198
 170 0072 00C0      		rjmp .L9
 171               	.L11:
 172               	/* epilogue start */
  66:cmod.c        ****   }
  67:cmod.c        **** }
 173               		.loc 1 67 0
 174 0074 0895      		ret
 175               		.cfi_endproc
 176               	.LFE4:
 178               	.global	byteTx
 180               	byteTx:
 181               	.LFB5:
  68:cmod.c        **** 
  69:cmod.c        **** // Transmit a byte over the serial port
  70:cmod.c        **** void byteTx(uint8_t value) {
 182               		.loc 1 70 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 188               	.LVL8:
 189               	.L14:
  71:cmod.c        ****   //while(!(UCSR0A & _BV(UDRE0))) ;
  72:cmod.c        ****   while(!(UCSR0A & 0x20)) ;
 190               		.loc 1 72 0 discriminator 1
 191 0076 9091 C000 		lds r25,192
 192 007a 95FF      		sbrs r25,5
 193 007c 00C0      		rjmp .L14
  73:cmod.c        ****   UDR0 = value;
 194               		.loc 1 73 0
 195 007e 8093 C600 		sts 198,r24
 196 0082 0895      		ret
 197               		.cfi_endproc
 198               	.LFE5:
 200               	.global	byteRx
 202               	byteRx:
 203               	.LFB6:
  74:cmod.c        **** }
  75:cmod.c        **** 
  76:cmod.c        **** uint8_t byteRx(void) {
 204               		.loc 1 76 0
 205               		.cfi_startproc
 206               	/* prologue: function */
 207               	/* frame size = 0 */
 208               	/* stack size = 0 */
 209               	.L__stack_usage = 0
 210               	.L17:
  77:cmod.c        ****   // Receive one byte from the robot.
  78:cmod.c        ****   // Call setupSerialPort() first.
  79:cmod.c        ****   // Wait for a byte to arrive in the recieve buffer.
  80:cmod.c        ****   while(!(UCSR0A & 0x80)) ;
 211               		.loc 1 80 0 discriminator 1
 212 0084 8091 C000 		lds r24,192
 213 0088 87FF      		sbrs r24,7
 214 008a 00C0      		rjmp .L17
  81:cmod.c        ****   
  82:cmod.c        ****   // Return that byte.
  83:cmod.c        ****   return UDR0;
 215               		.loc 1 83 0
 216 008c 8091 C600 		lds r24,198
  84:cmod.c        **** }
 217               		.loc 1 84 0
 218 0090 0895      		ret
 219               		.cfi_endproc
 220               	.LFE6:
 222               	.global	baud
 224               	baud:
 225               	.LFB7:
  85:cmod.c        **** 
  86:cmod.c        **** void baud(uint8_t baud_code) {
 226               		.loc 1 86 0
 227               		.cfi_startproc
 228               	.LVL9:
 229 0092 CF93      		push r28
 230               	.LCFI1:
 231               		.cfi_def_cfa_offset 3
 232               		.cfi_offset 28, -2
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 1 */
 236               	.L__stack_usage = 1
 237 0094 C82F      		mov r28,r24
  87:cmod.c        ****   // Switch the baud rate on both Create and module
  88:cmod.c        ****   if(baud_code <= 11)
 238               		.loc 1 88 0
 239 0096 8C30      		cpi r24,lo8(12)
 240 0098 00F0      		brlo .+2
 241 009a 00C0      		rjmp .L18
  89:cmod.c        ****   {
  90:cmod.c        ****     byteTx(CmdBaud);
 242               		.loc 1 90 0
 243 009c 81E8      		ldi r24,lo8(-127)
 244               	.LVL10:
 245 009e 0E94 0000 		call byteTx
 246               	.LVL11:
  91:cmod.c        ****     UCSR0A |= _BV(TXC0);
 247               		.loc 1 91 0
 248 00a2 8091 C000 		lds r24,192
 249 00a6 8064      		ori r24,lo8(64)
 250 00a8 8093 C000 		sts 192,r24
  92:cmod.c        ****     byteTx(baud_code);
 251               		.loc 1 92 0
 252 00ac 8C2F      		mov r24,r28
 253 00ae 0E94 0000 		call byteTx
 254               	.LVL12:
 255               	.L21:
  93:cmod.c        ****     // Wait until transmit is complete
  94:cmod.c        ****     while(!(UCSR0A & _BV(TXC0))) ;
 256               		.loc 1 94 0 discriminator 1
 257 00b2 8091 C000 		lds r24,192
 258 00b6 86FF      		sbrs r24,6
 259 00b8 00C0      		rjmp .L21
  95:cmod.c        **** 
  96:cmod.c        ****     cli();
 260               		.loc 1 96 0
 261               	/* #APP */
 262               	 ;  96 "cmod.c" 1
 263 00ba F894      		cli
 264               	 ;  0 "" 2
  97:cmod.c        **** 
  98:cmod.c        ****     // Switch the baud rate register
  99:cmod.c        ****     if(baud_code == Baud115200) {
 265               		.loc 1 99 0
 266               	/* #NOAPP */
 267 00bc CB30      		cpi r28,lo8(11)
 268 00be 01F4      		brne .L22
 100:cmod.c        ****       UBRR0 = Ubrr115200;
 269               		.loc 1 100 0
 270 00c0 89E0      		ldi r24,lo8(9)
 271 00c2 90E0      		ldi r25,0
 272 00c4 00C0      		rjmp .L34
 273               	.L22:
 101:cmod.c        ****     } else if(baud_code == Baud57600) {
 274               		.loc 1 101 0
 275 00c6 CA30      		cpi r28,lo8(10)
 276 00c8 01F4      		brne .L24
 102:cmod.c        ****       UBRR0 = Ubrr57600;
 277               		.loc 1 102 0
 278 00ca 83E1      		ldi r24,lo8(19)
 279 00cc 90E0      		ldi r25,0
 280 00ce 00C0      		rjmp .L34
 281               	.L24:
 103:cmod.c        ****     } else if(baud_code == Baud38400) {
 282               		.loc 1 103 0
 283 00d0 C930      		cpi r28,lo8(9)
 284 00d2 01F4      		brne .L25
 104:cmod.c        ****       UBRR0 = Ubrr38400;
 285               		.loc 1 104 0
 286 00d4 8DE1      		ldi r24,lo8(29)
 287 00d6 90E0      		ldi r25,0
 288 00d8 00C0      		rjmp .L34
 289               	.L25:
 105:cmod.c        ****     } else if(baud_code == Baud28800) {
 290               		.loc 1 105 0
 291 00da C830      		cpi r28,lo8(8)
 292 00dc 01F4      		brne .L26
 106:cmod.c        ****       UBRR0 = Ubrr28800;
 293               		.loc 1 106 0
 294 00de 87E2      		ldi r24,lo8(39)
 295 00e0 90E0      		ldi r25,0
 296 00e2 00C0      		rjmp .L34
 297               	.L26:
 107:cmod.c        ****     } else if(baud_code == Baud19200) {
 298               		.loc 1 107 0
 299 00e4 C730      		cpi r28,lo8(7)
 300 00e6 01F4      		brne .L27
 108:cmod.c        ****       UBRR0 = Ubrr19200;
 301               		.loc 1 108 0
 302 00e8 8BE3      		ldi r24,lo8(59)
 303 00ea 90E0      		ldi r25,0
 304 00ec 00C0      		rjmp .L34
 305               	.L27:
 109:cmod.c        ****     } else if(baud_code == Baud14400) {
 306               		.loc 1 109 0
 307 00ee C630      		cpi r28,lo8(6)
 308 00f0 01F4      		brne .L28
 110:cmod.c        ****       UBRR0 = Ubrr14400;
 309               		.loc 1 110 0
 310 00f2 8FE4      		ldi r24,lo8(79)
 311 00f4 90E0      		ldi r25,0
 312 00f6 00C0      		rjmp .L34
 313               	.L28:
 111:cmod.c        ****     } else if(baud_code == Baud9600) {
 314               		.loc 1 111 0
 315 00f8 C530      		cpi r28,lo8(5)
 316 00fa 01F4      		brne .L29
 112:cmod.c        ****       UBRR0 = Ubrr9600;
 317               		.loc 1 112 0
 318 00fc 87E7      		ldi r24,lo8(119)
 319 00fe 90E0      		ldi r25,0
 320 0100 00C0      		rjmp .L34
 321               	.L29:
 113:cmod.c        ****     } else if(baud_code == Baud4800) {
 322               		.loc 1 113 0
 323 0102 C430      		cpi r28,lo8(4)
 324 0104 01F4      		brne .L30
 114:cmod.c        ****       UBRR0 = Ubrr4800;
 325               		.loc 1 114 0
 326 0106 8FEE      		ldi r24,lo8(-17)
 327 0108 90E0      		ldi r25,0
 328 010a 00C0      		rjmp .L34
 329               	.L30:
 115:cmod.c        ****     } else if(baud_code == Baud2400) {
 330               		.loc 1 115 0
 331 010c C330      		cpi r28,lo8(3)
 332 010e 01F4      		brne .L31
 116:cmod.c        ****       UBRR0 = Ubrr2400;
 333               		.loc 1 116 0
 334 0110 8FED      		ldi r24,lo8(-33)
 335 0112 91E0      		ldi r25,lo8(1)
 336 0114 00C0      		rjmp .L34
 337               	.L31:
 117:cmod.c        ****     } else if(baud_code == Baud1200) {
 338               		.loc 1 117 0
 339 0116 C230      		cpi r28,lo8(2)
 340 0118 01F4      		brne .L32
 118:cmod.c        ****       UBRR0 = Ubrr1200;
 341               		.loc 1 118 0
 342 011a 8FEB      		ldi r24,lo8(-65)
 343 011c 93E0      		ldi r25,lo8(3)
 344 011e 00C0      		rjmp .L34
 345               	.L32:
 119:cmod.c        ****     } else if(baud_code == Baud600) {
 346               		.loc 1 119 0
 347 0120 C130      		cpi r28,lo8(1)
 348 0122 01F4      		brne .L33
 120:cmod.c        ****       UBRR0 = Ubrr600;
 349               		.loc 1 120 0
 350 0124 8FE7      		ldi r24,lo8(127)
 351 0126 97E0      		ldi r25,lo8(7)
 352 0128 00C0      		rjmp .L34
 353               	.L33:
 121:cmod.c        ****     } else if(baud_code == Baud300) {
 122:cmod.c        ****       UBRR0 = Ubrr300;
 354               		.loc 1 122 0
 355 012a 8FEF      		ldi r24,lo8(-1)
 356 012c 9EE0      		ldi r25,lo8(14)
 357               	.L34:
 358 012e 9093 C500 		sts 196+1,r25
 359 0132 8093 C400 		sts 196,r24
 123:cmod.c        ****     }
 124:cmod.c        ****     sei();
 360               		.loc 1 124 0
 361               	/* #APP */
 362               	 ;  124 "cmod.c" 1
 363 0136 7894      		sei
 364               	 ;  0 "" 2
 125:cmod.c        **** 
 126:cmod.c        ****     delayMs(100);
 365               		.loc 1 126 0
 366               	/* #NOAPP */
 367 0138 84E6      		ldi r24,lo8(100)
 368 013a 90E0      		ldi r25,0
 369               	/* epilogue start */
 127:cmod.c        ****   }
 128:cmod.c        **** }
 370               		.loc 1 128 0
 371 013c CF91      		pop r28
 372               	.LVL13:
 126:cmod.c        ****     delayMs(100);
 373               		.loc 1 126 0
 374 013e 0C94 0000 		jmp delayMs
 375               	.LVL14:
 376               	.L18:
 377               	/* epilogue start */
 378               		.loc 1 128 0
 379 0142 CF91      		pop r28
 380 0144 0895      		ret
 381               		.cfi_endproc
 382               	.LFE7:
 384               	.Letext0:
 385               		.file 2 "/usr/lib/avr/include/stdint.h"
 386               		.file 3 "timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmod.c
     /tmp/ccXfANO1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccXfANO1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccXfANO1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccXfANO1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXfANO1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXfANO1.s:12     .text:0000000000000000 setupIOPins
     /tmp/ccXfANO1.s:44     .text:0000000000000018 setupSerialPort
     /tmp/ccXfANO1.s:75     .text:0000000000000034 initializeCommandModule
     /tmp/ccXfANO1.s:110    .text:0000000000000046 setSerialDestination
     /tmp/ccXfANO1.s:155    .text:0000000000000066 flushRx
     /tmp/ccXfANO1.s:180    .text:0000000000000076 byteTx
     /tmp/ccXfANO1.s:202    .text:0000000000000084 byteRx
     /tmp/ccXfANO1.s:224    .text:0000000000000092 baud

UNDEFINED SYMBOLS
setupTimer
delayMs
