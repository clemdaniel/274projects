   1               		.file	"steering.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	drive
  12               	drive:
  13               	.LFB1:
  14               		.file 1 "steering.c"
   1:steering.c    **** #include "timer.h"
   2:steering.c    **** #include "cmod.h"
   3:steering.c    **** #include "oi.h"
   4:steering.c    **** #include "steering.h"
   5:steering.c    **** 
   6:steering.c    **** /**	Turn the robot angle theta
   7:steering.c    ****  *		theta in radians (theta * 1000)
   8:steering.c    ****  *		positive angles indicate counter-clockwise turns
   9:steering.c    ****  *		negative angles indicate clockwise turns
  10:steering.c    ****  */
  11:steering.c    **** void turn(int theta) {
  12:steering.c    **** 	uint8_t rHi;
  13:steering.c    **** 	uint8_t rLo;
  14:steering.c    **** 	uint8_t lHi;
  15:steering.c    **** 	uint8_t lLo;
  16:steering.c    **** 
  17:steering.c    **** 	if (theta > 0) {
  18:steering.c    **** 		rHi = vHiPos;
  19:steering.c    **** 		rLo = vLoPos;
  20:steering.c    **** 		lHi = vHiNeg;
  21:steering.c    **** 		lLo = vLoNeg;
  22:steering.c    **** 	} else {
  23:steering.c    **** 		rHi = vHiNeg;
  24:steering.c    **** 		rLo = vLoNeg;
  25:steering.c    **** 		lHi = vHiPos;
  26:steering.c    **** 		lLo = vLoPos;
  27:steering.c    **** 		theta *= -1;
  28:steering.c    **** 	}
  29:steering.c    **** 
  30:steering.c    **** 	byteTx(CmdDriveWheels);
  31:steering.c    **** 	byteTx(rHi);
  32:steering.c    **** 	byteTx(rLo);
  33:steering.c    **** 	byteTx(lHi);
  34:steering.c    **** 	byteTx(lLo);
  35:steering.c    **** 
  36:steering.c    **** 	delayMs(theta);
  37:steering.c    **** 	stop();
  38:steering.c    **** }
  39:steering.c    **** 
  40:steering.c    **** /**	Drive the robot at rate 'rate' until stopped
  41:steering.c    ****  *		rate in mm/s
  42:steering.c    ****  */
  43:steering.c    **** void drive(int rate) {
  15               		.loc 1 43 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  30 0004 EC01      		movw r28,r24
  31               	.LVL1:
  44:steering.c    **** 	//rate to hi/lo
  45:steering.c    **** 	uint8_t hi = 0x00;
  46:steering.c    **** 	uint8_t lo = 0x00;
  47:steering.c    ****   
  48:steering.c    ****   //skeleton left here for future use when driving backward may
  49:steering.c    ****   //be necessary
  50:steering.c    **** 	//if (rate > 0) {
  51:steering.c    **** 		hi |= rate >> 8;
  52:steering.c    **** 		lo |= rate; 
  53:steering.c    **** 	//} else if (rate < 0) {
  54:steering.c    **** 		//use two compliment
  55:steering.c    **** 		//not currently necessary
  56:steering.c    **** 	//}
  57:steering.c    **** 
  58:steering.c    **** 	byteTx(CmdDriveWheels);
  32               		.loc 1 58 0
  33 0006 81E9      		ldi r24,lo8(-111)
  34               	.LVL2:
  35 0008 0E94 0000 		call byteTx
  36               	.LVL3:
  59:steering.c    **** 	byteTx(hi);
  37               		.loc 1 59 0
  38 000c 8D2F      		mov r24,r29
  39 000e 0E94 0000 		call byteTx
  40               	.LVL4:
  60:steering.c    **** 	byteTx(lo);
  41               		.loc 1 60 0
  42 0012 8C2F      		mov r24,r28
  43 0014 0E94 0000 		call byteTx
  44               	.LVL5:
  61:steering.c    **** 	byteTx(hi);
  45               		.loc 1 61 0
  46 0018 8D2F      		mov r24,r29
  47 001a 0E94 0000 		call byteTx
  48               	.LVL6:
  62:steering.c    **** 	byteTx(lo);
  49               		.loc 1 62 0
  50 001e 8C2F      		mov r24,r28
  51               	/* epilogue start */
  63:steering.c    **** }
  52               		.loc 1 63 0
  53 0020 DF91      		pop r29
  54               	.LVL7:
  55 0022 CF91      		pop r28
  56               	.LVL8:
  62:steering.c    **** 	byteTx(lo);
  57               		.loc 1 62 0
  58 0024 0C94 0000 		jmp byteTx
  59               	.LVL9:
  60               		.cfi_endproc
  61               	.LFE1:
  63               	.global	stop
  65               	stop:
  66               	.LFB2:
  64:steering.c    **** 
  65:steering.c    **** /** Stop the robot	*/
  66:steering.c    **** void stop(void) {
  67               		.loc 1 66 0
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  67:steering.c    **** 	drive(0);
  73               		.loc 1 67 0
  74 0028 80E0      		ldi r24,0
  75 002a 90E0      		ldi r25,0
  76 002c 0C94 0000 		jmp drive
  77               	.LVL10:
  78               		.cfi_endproc
  79               	.LFE2:
  81               	.global	turn
  83               	turn:
  84               	.LFB0:
  11:steering.c    **** void turn(int theta) {
  85               		.loc 1 11 0
  86               		.cfi_startproc
  87               	.LVL11:
  88 0030 CF92      		push r12
  89               	.LCFI2:
  90               		.cfi_def_cfa_offset 3
  91               		.cfi_offset 12, -2
  92 0032 DF92      		push r13
  93               	.LCFI3:
  94               		.cfi_def_cfa_offset 4
  95               		.cfi_offset 13, -3
  96 0034 FF92      		push r15
  97               	.LCFI4:
  98               		.cfi_def_cfa_offset 5
  99               		.cfi_offset 15, -4
 100 0036 0F93      		push r16
 101               	.LCFI5:
 102               		.cfi_def_cfa_offset 6
 103               		.cfi_offset 16, -5
 104 0038 1F93      		push r17
 105               	.LCFI6:
 106               		.cfi_def_cfa_offset 7
 107               		.cfi_offset 17, -6
 108 003a CF93      		push r28
 109               	.LCFI7:
 110               		.cfi_def_cfa_offset 8
 111               		.cfi_offset 28, -7
 112 003c DF93      		push r29
 113               	.LCFI8:
 114               		.cfi_def_cfa_offset 9
 115               		.cfi_offset 29, -8
 116 003e 1F92      		push __zero_reg__
 117               	.LCFI9:
 118               		.cfi_def_cfa_offset 10
 119 0040 CDB7      		in r28,__SP_L__
 120 0042 DEB7      		in r29,__SP_H__
 121               	.LCFI10:
 122               		.cfi_def_cfa_register 28
 123               	/* prologue: function */
 124               	/* frame size = 1 */
 125               	/* stack size = 8 */
 126               	.L__stack_usage = 8
 127 0044 6C01      		movw r12,r24
  17:steering.c    **** 	if (theta > 0) {
 128               		.loc 1 17 0
 129 0046 1816      		cp __zero_reg__,r24
 130 0048 1906      		cpc __zero_reg__,r25
 131 004a 04F0      		brlt .L5
 132               	.LVL12:
  27:steering.c    **** 		theta *= -1;
 133               		.loc 1 27 0
 134 004c D194      		neg r13
 135 004e C194      		neg r12
 136 0050 D108      		sbc r13,__zero_reg__
 137               	.LVL13:
  26:steering.c    **** 		lLo = vLoPos;
 138               		.loc 1 26 0
 139 0052 15EA      		ldi r17,lo8(-91)
  25:steering.c    **** 		lHi = vHiPos;
 140               		.loc 1 25 0
 141 0054 00E0      		ldi r16,0
  24:steering.c    **** 		rLo = vLoNeg;
 142               		.loc 1 24 0
 143 0056 9BE5      		ldi r25,lo8(91)
  23:steering.c    **** 		rHi = vHiNeg;
 144               		.loc 1 23 0
 145 0058 FF24      		clr r15
 146 005a FA94      		dec r15
 147 005c 00C0      		rjmp .L4
 148               	.LVL14:
 149               	.L5:
  21:steering.c    **** 		lLo = vLoNeg;
 150               		.loc 1 21 0
 151 005e 1BE5      		ldi r17,lo8(91)
  20:steering.c    **** 		lHi = vHiNeg;
 152               		.loc 1 20 0
 153 0060 0FEF      		ldi r16,lo8(-1)
  19:steering.c    **** 		rLo = vLoPos;
 154               		.loc 1 19 0
 155 0062 95EA      		ldi r25,lo8(-91)
  18:steering.c    **** 		rHi = vHiPos;
 156               		.loc 1 18 0
 157 0064 F12C      		mov r15,__zero_reg__
 158               	.L4:
 159               	.LVL15:
  30:steering.c    **** 	byteTx(CmdDriveWheels);
 160               		.loc 1 30 0
 161 0066 81E9      		ldi r24,lo8(-111)
 162 0068 9983      		std Y+1,r25
 163 006a 0E94 0000 		call byteTx
 164               	.LVL16:
  31:steering.c    **** 	byteTx(rHi);
 165               		.loc 1 31 0
 166 006e 8F2D      		mov r24,r15
 167 0070 0E94 0000 		call byteTx
 168               	.LVL17:
  32:steering.c    **** 	byteTx(rLo);
 169               		.loc 1 32 0
 170 0074 9981      		ldd r25,Y+1
 171 0076 892F      		mov r24,r25
 172 0078 0E94 0000 		call byteTx
 173               	.LVL18:
  33:steering.c    **** 	byteTx(lHi);
 174               		.loc 1 33 0
 175 007c 802F      		mov r24,r16
 176 007e 0E94 0000 		call byteTx
 177               	.LVL19:
  34:steering.c    **** 	byteTx(lLo);
 178               		.loc 1 34 0
 179 0082 812F      		mov r24,r17
 180 0084 0E94 0000 		call byteTx
 181               	.LVL20:
  36:steering.c    **** 	delayMs(theta);
 182               		.loc 1 36 0
 183 0088 C601      		movw r24,r12
 184 008a 0E94 0000 		call delayMs
 185               	.LVL21:
 186               	/* epilogue start */
  38:steering.c    **** }
 187               		.loc 1 38 0
 188 008e 0F90      		pop __tmp_reg__
 189 0090 DF91      		pop r29
 190 0092 CF91      		pop r28
 191 0094 1F91      		pop r17
 192               	.LVL22:
 193 0096 0F91      		pop r16
 194               	.LVL23:
 195 0098 FF90      		pop r15
 196               	.LVL24:
 197 009a DF90      		pop r13
 198 009c CF90      		pop r12
 199               	.LVL25:
  37:steering.c    **** 	stop();
 200               		.loc 1 37 0
 201 009e 0C94 0000 		jmp stop
 202               	.LVL26:
 203               		.cfi_endproc
 204               	.LFE0:
 206               	.global	pentagon
 208               	pentagon:
 209               	.LFB3:
  68:steering.c    **** }
  69:steering.c    **** 
  70:steering.c    **** /** Make the robot drive in a pentagon shape
  71:steering.c    ****  *		direction only -1 or 1
  72:steering.c    ****  *			1 indicates counter-clockwise
  73:steering.c    ****  * 	  	-1 indicates clockwise
  74:steering.c    ****  */
  75:steering.c    **** void pentagon(int direction) {
 210               		.loc 1 75 0
 211               		.cfi_startproc
 212               	.LVL27:
 213 00a2 0F93      		push r16
 214               	.LCFI11:
 215               		.cfi_def_cfa_offset 3
 216               		.cfi_offset 16, -2
 217 00a4 1F93      		push r17
 218               	.LCFI12:
 219               		.cfi_def_cfa_offset 4
 220               		.cfi_offset 17, -3
 221 00a6 CF93      		push r28
 222               	.LCFI13:
 223               		.cfi_def_cfa_offset 5
 224               		.cfi_offset 28, -4
 225 00a8 DF93      		push r29
 226               	.LCFI14:
 227               		.cfi_def_cfa_offset 6
 228               		.cfi_offset 29, -5
 229               	/* prologue: function */
 230               	/* frame size = 0 */
 231               	/* stack size = 4 */
 232               	.L__stack_usage = 4
 233               	.LVL28:
  76:steering.c    **** 	int i;
  77:steering.c    **** 	for (i=0; i<5; i++) {
  78:steering.c    **** 				//drive at 100mm/s        
  79:steering.c    **** 				drive(100);
  80:steering.c    ****         //drive for 8000ms = 8s, 8s * 100 mm/s = 800 mm = 80cm
  81:steering.c    **** 				delayMs(8000); 
  82:steering.c    ****         stop();
  83:steering.c    **** 				//turn at angle 3*pi/5 radians
  84:steering.c    **** 				//(don't turn after the last leg)
  85:steering.c    ****         if (i != 4) turn((int)(direction*3*PI/5) * 1000);
 234               		.loc 1 85 0
 235 00aa 29E0      		ldi r18,lo8(9)
 236 00ac AC01      		movw r20,r24
 237 00ae 249F      		mul r18,r20
 238 00b0 C001      		movw r24,r0
 239 00b2 259F      		mul r18,r21
 240 00b4 900D      		add r25,r0
 241 00b6 1124      		clr __zero_reg__
 242               	.LVL29:
 243 00b8 65E0      		ldi r22,lo8(5)
 244 00ba 70E0      		ldi r23,0
 245 00bc 0E94 0000 		call __divmodhi4
 246 00c0 88EE      		ldi r24,lo8(-24)
 247 00c2 93E0      		ldi r25,lo8(3)
 248 00c4 689F      		mul r22,r24
 249 00c6 8001      		movw r16,r0
 250 00c8 699F      		mul r22,r25
 251 00ca 100D      		add r17,r0
 252 00cc 789F      		mul r23,r24
 253 00ce 100D      		add r17,r0
 254 00d0 1124      		clr r1
  77:steering.c    **** 	for (i=0; i<5; i++) {
 255               		.loc 1 77 0
 256 00d2 C0E0      		ldi r28,0
 257 00d4 D0E0      		ldi r29,0
 258               	.LVL30:
 259               	.L10:
  79:steering.c    **** 				drive(100);
 260               		.loc 1 79 0
 261 00d6 84E6      		ldi r24,lo8(100)
 262 00d8 90E0      		ldi r25,0
 263 00da 0E94 0000 		call drive
 264               	.LVL31:
  81:steering.c    **** 				delayMs(8000); 
 265               		.loc 1 81 0
 266 00de 80E4      		ldi r24,lo8(64)
 267 00e0 9FE1      		ldi r25,lo8(31)
 268 00e2 0E94 0000 		call delayMs
 269               	.LVL32:
  82:steering.c    ****         stop();
 270               		.loc 1 82 0
 271 00e6 0E94 0000 		call stop
 272               	.LVL33:
 273               		.loc 1 85 0
 274 00ea C430      		cpi r28,4
 275 00ec D105      		cpc r29,__zero_reg__
 276 00ee 01F0      		breq .L8
 277               		.loc 1 85 0 is_stmt 0 discriminator 1
 278 00f0 C801      		movw r24,r16
 279 00f2 0E94 0000 		call turn
 280               	.LVL34:
 281               	.L8:
  77:steering.c    **** 	for (i=0; i<5; i++) {
 282               		.loc 1 77 0 is_stmt 1
 283 00f6 2196      		adiw r28,1
 284               	.LVL35:
 285 00f8 C530      		cpi r28,5
 286 00fa D105      		cpc r29,__zero_reg__
 287 00fc 01F4      		brne .L10
 288               	/* epilogue start */
  86:steering.c    ****     } 
  87:steering.c    **** }
 289               		.loc 1 87 0
 290 00fe DF91      		pop r29
 291 0100 CF91      		pop r28
 292               	.LVL36:
 293 0102 1F91      		pop r17
 294 0104 0F91      		pop r16
 295 0106 0895      		ret
 296               		.cfi_endproc
 297               	.LFE3:
 299               		.comm	IR,1,1
 300               	.Letext0:
 301               		.file 2 "/usr/lib/avr/include/stdint.h"
 302               		.file 3 "timer.h"
 303               		.file 4 "cmod.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 steering.c
     /tmp/ccZAjP4b.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccZAjP4b.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccZAjP4b.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccZAjP4b.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccZAjP4b.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccZAjP4b.s:12     .text:0000000000000000 drive
     /tmp/ccZAjP4b.s:65     .text:0000000000000028 stop
     /tmp/ccZAjP4b.s:83     .text:0000000000000030 turn
     /tmp/ccZAjP4b.s:208    .text:00000000000000a2 pentagon
                            *COM*:0000000000000001 IR

UNDEFINED SYMBOLS
byteTx
delayMs
__divmodhi4
__do_clear_bss
