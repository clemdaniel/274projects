   1               		.file	"cmod.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupIOPins
  12               	setupIOPins:
  13               	.LFB1:
  14               		.file 1 "cmod.c"
   1:cmod.c        **** #include "cmod.h"
   2:cmod.c        **** #include "oi.h"
   3:cmod.c        **** #include "timer.h"
   4:cmod.c        **** 
   5:cmod.c        **** void initializeCommandModule(void){
   6:cmod.c        ****   // Disable interrupts. ("Clear interrupt bit")
   7:cmod.c        ****   cli();
   8:cmod.c        **** 
   9:cmod.c        ****   // One-time setup operations.
  10:cmod.c        ****   setupIOPins();
  11:cmod.c        ****   setupTimer();
  12:cmod.c        ****   setupSerialPort();
  13:cmod.c        **** 
  14:cmod.c        ****   // Enable interrupts. ("Set interrupt bit")
  15:cmod.c        ****   sei();
  16:cmod.c        **** }
  17:cmod.c        **** 
  18:cmod.c        **** void setupIOPins(void) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  19:cmod.c        ****   // Set I/O pins
  20:cmod.c        ****   DDRB  = 0x10;
  21               		.loc 1 20 0
  22 0000 80E1      		ldi r24,lo8(16)
  23 0002 84B9      		out 0x4,r24
  21:cmod.c        ****   PORTB = 0xCF;
  24               		.loc 1 21 0
  25 0004 8FEC      		ldi r24,lo8(-49)
  26 0006 85B9      		out 0x5,r24
  22:cmod.c        ****   DDRC  = 0x00;
  27               		.loc 1 22 0
  28 0008 17B8      		out 0x7,__zero_reg__
  23:cmod.c        ****   PORTC = 0xFF;
  29               		.loc 1 23 0
  30 000a 8FEF      		ldi r24,lo8(-1)
  31 000c 88B9      		out 0x8,r24
  24:cmod.c        ****   DDRD  = 0xE6;
  32               		.loc 1 24 0
  33 000e 86EE      		ldi r24,lo8(-26)
  34 0010 8AB9      		out 0xa,r24
  25:cmod.c        ****   PORTD = 0x7D;
  35               		.loc 1 25 0
  36 0012 8DE7      		ldi r24,lo8(125)
  37 0014 8BB9      		out 0xb,r24
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE1:
  42               	.global	setupSerialPort
  44               	setupSerialPort:
  45               	.LFB2:
  26:cmod.c        **** }
  27:cmod.c        **** 
  28:cmod.c        **** void setupSerialPort(void) {
  46               		.loc 1 28 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  29:cmod.c        ****   // Set the transmission speed to 57600 baud, which is what the Create expects,
  30:cmod.c        ****   // unless we tell it otherwise.
  31:cmod.c        ****   UBRR0 = 19;
  52               		.loc 1 31 0
  53 0018 83E1      		ldi r24,lo8(19)
  54 001a 90E0      		ldi r25,0
  55 001c 9093 C500 		sts 196+1,r25
  56 0020 8093 C400 		sts 196,r24
  32:cmod.c        ****   
  33:cmod.c        ****   // Enable both transmit and receive.
  34:cmod.c        ****   UCSR0B = (_BV(RXCIE0) | _BV(TXEN0) | _BV(RXEN0));
  57               		.loc 1 34 0
  58 0024 88E9      		ldi r24,lo8(-104)
  59 0026 8093 C100 		sts 193,r24
  35:cmod.c        ****     // UCSR0B = 0x18;
  36:cmod.c        ****   
  37:cmod.c        ****   // Set 8-bit data.
  38:cmod.c        ****   UCSR0C = (_BV(UCSZ00) | _BV(UCSZ01));
  60               		.loc 1 38 0
  61 002a 86E0      		ldi r24,lo8(6)
  62 002c 8093 C200 		sts 194,r24
  39:cmod.c        ****     // UCSR0C = 0x06;
  40:cmod.c        **** 
  41:cmod.c        ****   //Turn on interupts
  42:cmod.c        ****   sei();
  63               		.loc 1 42 0
  64               	/* #APP */
  65               	 ;  42 "cmod.c" 1
  66 0030 7894      		sei
  67               	 ;  0 "" 2
  68               	/* #NOAPP */
  69 0032 0895      		ret
  70               		.cfi_endproc
  71               	.LFE2:
  73               	.global	initializeCommandModule
  75               	initializeCommandModule:
  76               	.LFB0:
   5:cmod.c        **** void initializeCommandModule(void){
  77               		.loc 1 5 0
  78               		.cfi_startproc
  79               	/* prologue: function */
  80               	/* frame size = 0 */
  81               	/* stack size = 0 */
  82               	.L__stack_usage = 0
   7:cmod.c        ****   cli();
  83               		.loc 1 7 0
  84               	/* #APP */
  85               	 ;  7 "cmod.c" 1
  86 0034 F894      		cli
  87               	 ;  0 "" 2
  10:cmod.c        ****   setupIOPins();
  88               		.loc 1 10 0
  89               	/* #NOAPP */
  90 0036 0E94 0000 		call setupIOPins
  91               	.LVL0:
  11:cmod.c        ****   setupTimer();
  92               		.loc 1 11 0
  93 003a 0E94 0000 		call setupTimer
  94               	.LVL1:
  12:cmod.c        ****   setupSerialPort();
  95               		.loc 1 12 0
  96 003e 0E94 0000 		call setupSerialPort
  97               	.LVL2:
  15:cmod.c        ****   sei();
  98               		.loc 1 15 0
  99               	/* #APP */
 100               	 ;  15 "cmod.c" 1
 101 0042 7894      		sei
 102               	 ;  0 "" 2
 103               	/* #NOAPP */
 104 0044 0895      		ret
 105               		.cfi_endproc
 106               	.LFE0:
 108               	.global	byteTx
 110               	byteTx:
 111               	.LFB3:
  43:cmod.c        **** }
  44:cmod.c        **** 
  45:cmod.c        **** // void byteTx(uint8_t value) {
  46:cmod.c        **** //   // Transmit one byte to the robot.
  47:cmod.c        **** //   // Wait for the buffer to be empty.
  48:cmod.c        **** //   while(!(UCSR0A & 0x20)) ;
  49:cmod.c        **** 
  50:cmod.c        **** //   // Send the byte.
  51:cmod.c        **** //   UDR0 = value;
  52:cmod.c        **** // }
  53:cmod.c        **** 
  54:cmod.c        **** // Transmit a byte over the serial port
  55:cmod.c        **** void byteTx(uint8_t value) {
 112               		.loc 1 55 0
 113               		.cfi_startproc
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 118               	.LVL3:
 119               	.L6:
  56:cmod.c        ****   while(!(UCSR0A & _BV(UDRE0))) ;
 120               		.loc 1 56 0 discriminator 1
 121 0046 9091 C000 		lds r25,192
 122 004a 95FF      		sbrs r25,5
 123 004c 00C0      		rjmp .L6
  57:cmod.c        ****   UDR0 = value;
 124               		.loc 1 57 0
 125 004e 8093 C600 		sts 198,r24
 126 0052 0895      		ret
 127               		.cfi_endproc
 128               	.LFE3:
 130               	.global	byteRx
 132               	byteRx:
 133               	.LFB4:
  58:cmod.c        **** }
  59:cmod.c        **** 
  60:cmod.c        **** uint8_t byteRx(void) {
 134               		.loc 1 60 0
 135               		.cfi_startproc
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 140               	.L10:
  61:cmod.c        ****   // Receive one byte from the robot.
  62:cmod.c        ****   // Call setupSerialPort() first.
  63:cmod.c        ****   // Wait for a byte to arrive in the recieve buffer.
  64:cmod.c        ****   while(!(UCSR0A & 0x80)) ;
 141               		.loc 1 64 0 discriminator 1
 142 0054 8091 C000 		lds r24,192
 143 0058 87FF      		sbrs r24,7
 144 005a 00C0      		rjmp .L10
  65:cmod.c        ****   
  66:cmod.c        ****   // Return that byte.
  67:cmod.c        ****   return UDR0;
 145               		.loc 1 67 0
 146 005c 8091 C600 		lds r24,198
  68:cmod.c        **** }
 147               		.loc 1 68 0
 148 0060 0895      		ret
 149               		.cfi_endproc
 150               	.LFE4:
 152               	.global	baud
 154               	baud:
 155               	.LFB5:
  69:cmod.c        **** 
  70:cmod.c        **** void baud(uint8_t baud_code) {
 156               		.loc 1 70 0
 157               		.cfi_startproc
 158               	.LVL4:
 159 0062 CF93      		push r28
 160               	.LCFI0:
 161               		.cfi_def_cfa_offset 3
 162               		.cfi_offset 28, -2
 163               	/* prologue: function */
 164               	/* frame size = 0 */
 165               	/* stack size = 1 */
 166               	.L__stack_usage = 1
 167 0064 C82F      		mov r28,r24
  71:cmod.c        ****   // Switch the baud rate on both Create and module
  72:cmod.c        ****   if(baud_code <= 11)
 168               		.loc 1 72 0
 169 0066 8C30      		cpi r24,lo8(12)
 170 0068 00F0      		brlo .+2
 171 006a 00C0      		rjmp .L11
  73:cmod.c        ****   {
  74:cmod.c        ****     byteTx(CmdBaud);
 172               		.loc 1 74 0
 173 006c 81E8      		ldi r24,lo8(-127)
 174               	.LVL5:
 175 006e 0E94 0000 		call byteTx
 176               	.LVL6:
  75:cmod.c        ****     UCSR0A |= _BV(TXC0);
 177               		.loc 1 75 0
 178 0072 8091 C000 		lds r24,192
 179 0076 8064      		ori r24,lo8(64)
 180 0078 8093 C000 		sts 192,r24
  76:cmod.c        ****     byteTx(baud_code);
 181               		.loc 1 76 0
 182 007c 8C2F      		mov r24,r28
 183 007e 0E94 0000 		call byteTx
 184               	.LVL7:
 185               	.L14:
  77:cmod.c        ****     // Wait until transmit is complete
  78:cmod.c        ****     while(!(UCSR0A & _BV(TXC0))) ;
 186               		.loc 1 78 0 discriminator 1
 187 0082 8091 C000 		lds r24,192
 188 0086 86FF      		sbrs r24,6
 189 0088 00C0      		rjmp .L14
  79:cmod.c        **** 
  80:cmod.c        ****     cli();
 190               		.loc 1 80 0
 191               	/* #APP */
 192               	 ;  80 "cmod.c" 1
 193 008a F894      		cli
 194               	 ;  0 "" 2
  81:cmod.c        **** 
  82:cmod.c        ****     // Switch the baud rate register
  83:cmod.c        ****     if(baud_code == Baud115200) {
 195               		.loc 1 83 0
 196               	/* #NOAPP */
 197 008c CB30      		cpi r28,lo8(11)
 198 008e 01F4      		brne .L15
  84:cmod.c        ****       UBRR0 = Ubrr115200;
 199               		.loc 1 84 0
 200 0090 89E0      		ldi r24,lo8(9)
 201 0092 90E0      		ldi r25,0
 202 0094 00C0      		rjmp .L27
 203               	.L15:
  85:cmod.c        ****     } else if(baud_code == Baud57600) {
 204               		.loc 1 85 0
 205 0096 CA30      		cpi r28,lo8(10)
 206 0098 01F4      		brne .L17
  86:cmod.c        ****       UBRR0 = Ubrr57600;
 207               		.loc 1 86 0
 208 009a 83E1      		ldi r24,lo8(19)
 209 009c 90E0      		ldi r25,0
 210 009e 00C0      		rjmp .L27
 211               	.L17:
  87:cmod.c        ****     } else if(baud_code == Baud38400) {
 212               		.loc 1 87 0
 213 00a0 C930      		cpi r28,lo8(9)
 214 00a2 01F4      		brne .L18
  88:cmod.c        ****       UBRR0 = Ubrr38400;
 215               		.loc 1 88 0
 216 00a4 8DE1      		ldi r24,lo8(29)
 217 00a6 90E0      		ldi r25,0
 218 00a8 00C0      		rjmp .L27
 219               	.L18:
  89:cmod.c        ****     } else if(baud_code == Baud28800) {
 220               		.loc 1 89 0
 221 00aa C830      		cpi r28,lo8(8)
 222 00ac 01F4      		brne .L19
  90:cmod.c        ****       UBRR0 = Ubrr28800;
 223               		.loc 1 90 0
 224 00ae 87E2      		ldi r24,lo8(39)
 225 00b0 90E0      		ldi r25,0
 226 00b2 00C0      		rjmp .L27
 227               	.L19:
  91:cmod.c        ****     } else if(baud_code == Baud19200) {
 228               		.loc 1 91 0
 229 00b4 C730      		cpi r28,lo8(7)
 230 00b6 01F4      		brne .L20
  92:cmod.c        ****       UBRR0 = Ubrr19200;
 231               		.loc 1 92 0
 232 00b8 8BE3      		ldi r24,lo8(59)
 233 00ba 90E0      		ldi r25,0
 234 00bc 00C0      		rjmp .L27
 235               	.L20:
  93:cmod.c        ****     } else if(baud_code == Baud14400) {
 236               		.loc 1 93 0
 237 00be C630      		cpi r28,lo8(6)
 238 00c0 01F4      		brne .L21
  94:cmod.c        ****       UBRR0 = Ubrr14400;
 239               		.loc 1 94 0
 240 00c2 8FE4      		ldi r24,lo8(79)
 241 00c4 90E0      		ldi r25,0
 242 00c6 00C0      		rjmp .L27
 243               	.L21:
  95:cmod.c        ****     } else if(baud_code == Baud9600) {
 244               		.loc 1 95 0
 245 00c8 C530      		cpi r28,lo8(5)
 246 00ca 01F4      		brne .L22
  96:cmod.c        ****       UBRR0 = Ubrr9600;
 247               		.loc 1 96 0
 248 00cc 87E7      		ldi r24,lo8(119)
 249 00ce 90E0      		ldi r25,0
 250 00d0 00C0      		rjmp .L27
 251               	.L22:
  97:cmod.c        ****     } else if(baud_code == Baud4800) {
 252               		.loc 1 97 0
 253 00d2 C430      		cpi r28,lo8(4)
 254 00d4 01F4      		brne .L23
  98:cmod.c        ****       UBRR0 = Ubrr4800;
 255               		.loc 1 98 0
 256 00d6 8FEE      		ldi r24,lo8(-17)
 257 00d8 90E0      		ldi r25,0
 258 00da 00C0      		rjmp .L27
 259               	.L23:
  99:cmod.c        ****     } else if(baud_code == Baud2400) {
 260               		.loc 1 99 0
 261 00dc C330      		cpi r28,lo8(3)
 262 00de 01F4      		brne .L24
 100:cmod.c        ****       UBRR0 = Ubrr2400;
 263               		.loc 1 100 0
 264 00e0 8FED      		ldi r24,lo8(-33)
 265 00e2 91E0      		ldi r25,lo8(1)
 266 00e4 00C0      		rjmp .L27
 267               	.L24:
 101:cmod.c        ****     } else if(baud_code == Baud1200) {
 268               		.loc 1 101 0
 269 00e6 C230      		cpi r28,lo8(2)
 270 00e8 01F4      		brne .L25
 102:cmod.c        ****       UBRR0 = Ubrr1200;
 271               		.loc 1 102 0
 272 00ea 8FEB      		ldi r24,lo8(-65)
 273 00ec 93E0      		ldi r25,lo8(3)
 274 00ee 00C0      		rjmp .L27
 275               	.L25:
 103:cmod.c        ****     } else if(baud_code == Baud600) {
 276               		.loc 1 103 0
 277 00f0 C130      		cpi r28,lo8(1)
 278 00f2 01F4      		brne .L26
 104:cmod.c        ****       UBRR0 = Ubrr600;
 279               		.loc 1 104 0
 280 00f4 8FE7      		ldi r24,lo8(127)
 281 00f6 97E0      		ldi r25,lo8(7)
 282 00f8 00C0      		rjmp .L27
 283               	.L26:
 105:cmod.c        ****     } else if(baud_code == Baud300) {
 106:cmod.c        ****       UBRR0 = Ubrr300;
 284               		.loc 1 106 0
 285 00fa 8FEF      		ldi r24,lo8(-1)
 286 00fc 9EE0      		ldi r25,lo8(14)
 287               	.L27:
 288 00fe 9093 C500 		sts 196+1,r25
 289 0102 8093 C400 		sts 196,r24
 107:cmod.c        ****     }
 108:cmod.c        ****     sei();
 290               		.loc 1 108 0
 291               	/* #APP */
 292               	 ;  108 "cmod.c" 1
 293 0106 7894      		sei
 294               	 ;  0 "" 2
 109:cmod.c        **** 
 110:cmod.c        ****     delayMs(100);
 295               		.loc 1 110 0
 296               	/* #NOAPP */
 297 0108 84E6      		ldi r24,lo8(100)
 298 010a 90E0      		ldi r25,0
 299               	/* epilogue start */
 111:cmod.c        ****   }
 112:cmod.c        **** }
 300               		.loc 1 112 0
 301 010c CF91      		pop r28
 302               	.LVL8:
 110:cmod.c        ****     delayMs(100);
 303               		.loc 1 110 0
 304 010e 0C94 0000 		jmp delayMs
 305               	.LVL9:
 306               	.L11:
 307               	/* epilogue start */
 308               		.loc 1 112 0
 309 0112 CF91      		pop r28
 310 0114 0895      		ret
 311               		.cfi_endproc
 312               	.LFE5:
 314               	.Letext0:
 315               		.file 2 "/usr/lib/avr/include/stdint.h"
 316               		.file 3 "timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmod.c
     /tmp/ccClDOso.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccClDOso.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccClDOso.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccClDOso.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccClDOso.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccClDOso.s:12     .text:0000000000000000 setupIOPins
     /tmp/ccClDOso.s:44     .text:0000000000000018 setupSerialPort
     /tmp/ccClDOso.s:75     .text:0000000000000034 initializeCommandModule
     /tmp/ccClDOso.s:110    .text:0000000000000046 byteTx
     /tmp/ccClDOso.s:132    .text:0000000000000054 byteRx
     /tmp/ccClDOso.s:154    .text:0000000000000062 baud

UNDEFINED SYMBOLS
setupTimer
delayMs
