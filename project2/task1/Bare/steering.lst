   1               		.file	"steering.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	drive
  12               	drive:
  13               	.LFB1:
  14               		.file 1 "steering.c"
   1:steering.c    **** #include "timer.h"
   2:steering.c    **** #include "cmod.h"
   3:steering.c    **** #include "oi.h"
   4:steering.c    **** #include "steering.h"
   5:steering.c    **** 
   6:steering.c    **** /**	Turn the robot angle theta
   7:steering.c    ****  *		theta in radians
   8:steering.c    ****  *		positive angles indicate counter-clockwise turns
   9:steering.c    ****  *		negative angles indicate clockwise turns
  10:steering.c    ****  */
  11:steering.c    **** void turn(int theta) {
  12:steering.c    **** 	uint8_t rHi;
  13:steering.c    **** 	uint8_t rLo;
  14:steering.c    **** 	uint8_t lHi;
  15:steering.c    **** 	uint8_t lLo;
  16:steering.c    **** 
  17:steering.c    **** 	if (theta > 0) {
  18:steering.c    **** 		rHi = vHiPos;
  19:steering.c    **** 		rLo = vLoPos;
  20:steering.c    **** 		lHi = vHiNeg;
  21:steering.c    **** 		lLo = vLoNeg;
  22:steering.c    **** 	} else {
  23:steering.c    **** 		rHi = vHiNeg;
  24:steering.c    **** 		rLo = vLoNeg;
  25:steering.c    **** 		lHi = vHiPos;
  26:steering.c    **** 		lLo = vLoPos;
  27:steering.c    **** 		theta *= -1;
  28:steering.c    **** 	}
  29:steering.c    **** 
  30:steering.c    **** 	byteTx(CmdDriveWheels);
  31:steering.c    **** 	byteTx(rHi);
  32:steering.c    **** 	byteTx(rLo);
  33:steering.c    **** 	byteTx(lHi);
  34:steering.c    **** 	byteTx(lLo);
  35:steering.c    **** 
  36:steering.c    **** 	delayMs(theta);
  37:steering.c    **** 	stop();
  38:steering.c    **** }
  39:steering.c    **** 
  40:steering.c    **** /**	Drive the robot at rate 'rate' until stopped
  41:steering.c    ****  *		rate in mm/s
  42:steering.c    ****  */
  43:steering.c    **** void drive(int rate) {
  15               		.loc 1 43 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  30 0004 EC01      		movw r28,r24
  31               	.LVL1:
  44:steering.c    **** 	//rate to hi/lo
  45:steering.c    **** 	uint8_t hi = 0x00;
  46:steering.c    **** 	uint8_t lo = 0x00;
  47:steering.c    ****   
  48:steering.c    ****   //skeleton left here for future use when driving backward may
  49:steering.c    ****   //be necessary
  50:steering.c    **** 	//if (rate > 0) {
  51:steering.c    **** 		hi |= rate >> 8;
  52:steering.c    **** 		lo |= rate; 
  53:steering.c    **** 	//} else if (rate < 0) {
  54:steering.c    **** 		//use two compliment
  55:steering.c    **** 		//not currently necessary
  56:steering.c    **** 	//}
  57:steering.c    **** 
  58:steering.c    **** 	byteTx(CmdDriveWheels);
  32               		.loc 1 58 0
  33 0006 81E9      		ldi r24,lo8(-111)
  34               	.LVL2:
  35 0008 0E94 0000 		call byteTx
  36               	.LVL3:
  59:steering.c    **** 	byteTx(hi);
  37               		.loc 1 59 0
  38 000c 8D2F      		mov r24,r29
  39 000e 0E94 0000 		call byteTx
  40               	.LVL4:
  60:steering.c    **** 	byteTx(lo);
  41               		.loc 1 60 0
  42 0012 8C2F      		mov r24,r28
  43 0014 0E94 0000 		call byteTx
  44               	.LVL5:
  61:steering.c    **** 	byteTx(hi);
  45               		.loc 1 61 0
  46 0018 8D2F      		mov r24,r29
  47 001a 0E94 0000 		call byteTx
  48               	.LVL6:
  62:steering.c    **** 	byteTx(lo);
  49               		.loc 1 62 0
  50 001e 8C2F      		mov r24,r28
  51               	/* epilogue start */
  63:steering.c    **** }
  52               		.loc 1 63 0
  53 0020 DF91      		pop r29
  54               	.LVL7:
  55 0022 CF91      		pop r28
  56               	.LVL8:
  62:steering.c    **** 	byteTx(lo);
  57               		.loc 1 62 0
  58 0024 0C94 0000 		jmp byteTx
  59               	.LVL9:
  60               		.cfi_endproc
  61               	.LFE1:
  63               	.global	stop
  65               	stop:
  66               	.LFB2:
  64:steering.c    **** 
  65:steering.c    **** /** Stop the robot	*/
  66:steering.c    **** void stop(void) {
  67               		.loc 1 66 0
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  67:steering.c    **** 	drive(0);
  73               		.loc 1 67 0
  74 0028 80E0      		ldi r24,0
  75 002a 90E0      		ldi r25,0
  76 002c 0C94 0000 		jmp drive
  77               	.LVL10:
  78               		.cfi_endproc
  79               	.LFE2:
  81               	.global	turn
  83               	turn:
  84               	.LFB0:
  11:steering.c    **** void turn(int theta) {
  85               		.loc 1 11 0
  86               		.cfi_startproc
  87               	.LVL11:
  88 0030 CF92      		push r12
  89               	.LCFI2:
  90               		.cfi_def_cfa_offset 3
  91               		.cfi_offset 12, -2
  92 0032 DF92      		push r13
  93               	.LCFI3:
  94               		.cfi_def_cfa_offset 4
  95               		.cfi_offset 13, -3
  96 0034 FF92      		push r15
  97               	.LCFI4:
  98               		.cfi_def_cfa_offset 5
  99               		.cfi_offset 15, -4
 100 0036 0F93      		push r16
 101               	.LCFI5:
 102               		.cfi_def_cfa_offset 6
 103               		.cfi_offset 16, -5
 104 0038 1F93      		push r17
 105               	.LCFI6:
 106               		.cfi_def_cfa_offset 7
 107               		.cfi_offset 17, -6
 108 003a CF93      		push r28
 109               	.LCFI7:
 110               		.cfi_def_cfa_offset 8
 111               		.cfi_offset 28, -7
 112 003c DF93      		push r29
 113               	.LCFI8:
 114               		.cfi_def_cfa_offset 9
 115               		.cfi_offset 29, -8
 116 003e 1F92      		push __zero_reg__
 117               	.LCFI9:
 118               		.cfi_def_cfa_offset 10
 119 0040 CDB7      		in r28,__SP_L__
 120 0042 DEB7      		in r29,__SP_H__
 121               	.LCFI10:
 122               		.cfi_def_cfa_register 28
 123               	/* prologue: function */
 124               	/* frame size = 1 */
 125               	/* stack size = 8 */
 126               	.L__stack_usage = 8
 127 0044 6C01      		movw r12,r24
  17:steering.c    **** 	if (theta > 0) {
 128               		.loc 1 17 0
 129 0046 1816      		cp __zero_reg__,r24
 130 0048 1906      		cpc __zero_reg__,r25
 131 004a 04F0      		brlt .L5
 132               	.LVL12:
  27:steering.c    **** 		theta *= -1;
 133               		.loc 1 27 0
 134 004c D194      		neg r13
 135 004e C194      		neg r12
 136 0050 D108      		sbc r13,__zero_reg__
 137               	.LVL13:
  26:steering.c    **** 		lLo = vLoPos;
 138               		.loc 1 26 0
 139 0052 15EA      		ldi r17,lo8(-91)
  25:steering.c    **** 		lHi = vHiPos;
 140               		.loc 1 25 0
 141 0054 00E0      		ldi r16,0
  24:steering.c    **** 		rLo = vLoNeg;
 142               		.loc 1 24 0
 143 0056 9BE5      		ldi r25,lo8(91)
  23:steering.c    **** 		rHi = vHiNeg;
 144               		.loc 1 23 0
 145 0058 FF24      		clr r15
 146 005a FA94      		dec r15
 147 005c 00C0      		rjmp .L4
 148               	.LVL14:
 149               	.L5:
  21:steering.c    **** 		lLo = vLoNeg;
 150               		.loc 1 21 0
 151 005e 1BE5      		ldi r17,lo8(91)
  20:steering.c    **** 		lHi = vHiNeg;
 152               		.loc 1 20 0
 153 0060 0FEF      		ldi r16,lo8(-1)
  19:steering.c    **** 		rLo = vLoPos;
 154               		.loc 1 19 0
 155 0062 95EA      		ldi r25,lo8(-91)
  18:steering.c    **** 		rHi = vHiPos;
 156               		.loc 1 18 0
 157 0064 F12C      		mov r15,__zero_reg__
 158               	.L4:
 159               	.LVL15:
  30:steering.c    **** 	byteTx(CmdDriveWheels);
 160               		.loc 1 30 0
 161 0066 81E9      		ldi r24,lo8(-111)
 162 0068 9983      		std Y+1,r25
 163 006a 0E94 0000 		call byteTx
 164               	.LVL16:
  31:steering.c    **** 	byteTx(rHi);
 165               		.loc 1 31 0
 166 006e 8F2D      		mov r24,r15
 167 0070 0E94 0000 		call byteTx
 168               	.LVL17:
  32:steering.c    **** 	byteTx(rLo);
 169               		.loc 1 32 0
 170 0074 9981      		ldd r25,Y+1
 171 0076 892F      		mov r24,r25
 172 0078 0E94 0000 		call byteTx
 173               	.LVL18:
  33:steering.c    **** 	byteTx(lHi);
 174               		.loc 1 33 0
 175 007c 802F      		mov r24,r16
 176 007e 0E94 0000 		call byteTx
 177               	.LVL19:
  34:steering.c    **** 	byteTx(lLo);
 178               		.loc 1 34 0
 179 0082 812F      		mov r24,r17
 180 0084 0E94 0000 		call byteTx
 181               	.LVL20:
  36:steering.c    **** 	delayMs(theta);
 182               		.loc 1 36 0
 183 0088 C601      		movw r24,r12
 184 008a 0E94 0000 		call delayMs
 185               	.LVL21:
 186               	/* epilogue start */
  38:steering.c    **** }
 187               		.loc 1 38 0
 188 008e 0F90      		pop __tmp_reg__
 189 0090 DF91      		pop r29
 190 0092 CF91      		pop r28
 191 0094 1F91      		pop r17
 192               	.LVL22:
 193 0096 0F91      		pop r16
 194               	.LVL23:
 195 0098 FF90      		pop r15
 196               	.LVL24:
 197 009a DF90      		pop r13
 198 009c CF90      		pop r12
 199               	.LVL25:
  37:steering.c    **** 	stop();
 200               		.loc 1 37 0
 201 009e 0C94 0000 		jmp stop
 202               	.LVL26:
 203               		.cfi_endproc
 204               	.LFE0:
 206               	.global	__floatsisf
 207               	.global	__mulsf3
 208               	.global	__divsf3
 209               	.global	__fixsfsi
 210               	.global	pentagon
 212               	pentagon:
 213               	.LFB3:
  68:steering.c    **** }
  69:steering.c    **** 
  70:steering.c    **** /** Make the robot drive in a pentagon shape
  71:steering.c    ****  *		direction only -1 or 1
  72:steering.c    ****  *			1 indicates counter-clockwise
  73:steering.c    ****  * 	  	-1 indicates clockwise
  74:steering.c    ****  */
  75:steering.c    **** void pentagon(int direction) {
 214               		.loc 1 75 0
 215               		.cfi_startproc
 216               	.LVL27:
 217 00a2 CF92      		push r12
 218               	.LCFI11:
 219               		.cfi_def_cfa_offset 3
 220               		.cfi_offset 12, -2
 221 00a4 DF92      		push r13
 222               	.LCFI12:
 223               		.cfi_def_cfa_offset 4
 224               		.cfi_offset 13, -3
 225 00a6 EF92      		push r14
 226               	.LCFI13:
 227               		.cfi_def_cfa_offset 5
 228               		.cfi_offset 14, -4
 229 00a8 FF92      		push r15
 230               	.LCFI14:
 231               		.cfi_def_cfa_offset 6
 232               		.cfi_offset 15, -5
 233 00aa 0F93      		push r16
 234               	.LCFI15:
 235               		.cfi_def_cfa_offset 7
 236               		.cfi_offset 16, -6
 237 00ac 1F93      		push r17
 238               	.LCFI16:
 239               		.cfi_def_cfa_offset 8
 240               		.cfi_offset 17, -7
 241 00ae CF93      		push r28
 242               	.LCFI17:
 243               		.cfi_def_cfa_offset 9
 244               		.cfi_offset 28, -8
 245 00b0 DF93      		push r29
 246               	.LCFI18:
 247               		.cfi_def_cfa_offset 10
 248               		.cfi_offset 29, -9
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 8 */
 252               	.L__stack_usage = 8
 253               	.LVL28:
  76:steering.c    **** 	int i;
  77:steering.c    **** 	for (i=0; i<5; i++) {
  78:steering.c    **** 				//drive at 100mm/s        
  79:steering.c    **** 				drive(100);
  80:steering.c    ****         //drive for 8000ms = 8s, 8s * 100 mm/s = 800 mm = 80cm
  81:steering.c    **** 				delayMs(8000); 
  82:steering.c    ****         stop();
  83:steering.c    **** 				//turn at angle 3*pi/5 radians
  84:steering.c    **** 				//(don't turn after the last leg)
  85:steering.c    ****         if (i != 4) turn((int)(direction*3*PI/5) * 1000);
 254               		.loc 1 85 0
 255 00b2 6C01      		movw r12,r24
 256 00b4 CC0C      		lsl r12
 257 00b6 DD1C      		rol r13
 258 00b8 C80E      		add r12,r24
 259 00ba D91E      		adc r13,r25
  77:steering.c    **** 	for (i=0; i<5; i++) {
 260               		.loc 1 77 0
 261 00bc C0E0      		ldi r28,0
 262 00be D0E0      		ldi r29,0
 263               		.loc 1 85 0
 264 00c0 EE24      		clr r14
 265 00c2 D7FC      		sbrc r13,7
 266 00c4 E094      		com r14
 267 00c6 FE2C      		mov r15,r14
 268 00c8 08EE      		ldi r16,lo8(-24)
 269 00ca 13E0      		ldi r17,lo8(3)
 270               	.LVL29:
 271               	.L10:
  79:steering.c    **** 				drive(100);
 272               		.loc 1 79 0
 273 00cc 84E6      		ldi r24,lo8(100)
 274 00ce 90E0      		ldi r25,0
 275 00d0 0E94 0000 		call drive
 276               	.LVL30:
  81:steering.c    **** 				delayMs(8000); 
 277               		.loc 1 81 0
 278 00d4 80E4      		ldi r24,lo8(64)
 279 00d6 9FE1      		ldi r25,lo8(31)
 280 00d8 0E94 0000 		call delayMs
 281               	.LVL31:
  82:steering.c    ****         stop();
 282               		.loc 1 82 0
 283 00dc 0E94 0000 		call stop
 284               	.LVL32:
 285               		.loc 1 85 0
 286 00e0 C430      		cpi r28,4
 287 00e2 D105      		cpc r29,__zero_reg__
 288 00e4 01F0      		breq .L8
 289               		.loc 1 85 0 is_stmt 0 discriminator 1
 290 00e6 C701      		movw r24,r14
 291 00e8 B601      		movw r22,r12
 292 00ea 0E94 0000 		call __floatsisf
 293               	.LVL33:
 294 00ee 2AED      		ldi r18,lo8(-38)
 295 00f0 3FE0      		ldi r19,lo8(15)
 296 00f2 49E4      		ldi r20,lo8(73)
 297 00f4 50E4      		ldi r21,lo8(64)
 298 00f6 0E94 0000 		call __mulsf3
 299               	.LVL34:
 300 00fa 20E0      		ldi r18,0
 301 00fc 30E0      		ldi r19,0
 302 00fe 40EA      		ldi r20,lo8(-96)
 303 0100 50E4      		ldi r21,lo8(64)
 304 0102 0E94 0000 		call __divsf3
 305               	.LVL35:
 306 0106 0E94 0000 		call __fixsfsi
 307               	.LVL36:
 308 010a 069F      		mul r16,r22
 309 010c 9001      		movw r18,r0
 310 010e 079F      		mul r16,r23
 311 0110 300D      		add r19,r0
 312 0112 169F      		mul r17,r22
 313 0114 300D      		add r19,r0
 314 0116 1124      		clr r1
 315 0118 C901      		movw r24,r18
 316 011a 0E94 0000 		call turn
 317               	.LVL37:
 318               	.L8:
  77:steering.c    **** 	for (i=0; i<5; i++) {
 319               		.loc 1 77 0 is_stmt 1
 320 011e 2196      		adiw r28,1
 321               	.LVL38:
 322 0120 C530      		cpi r28,5
 323 0122 D105      		cpc r29,__zero_reg__
 324 0124 01F4      		brne .L10
 325               	/* epilogue start */
  86:steering.c    ****     } 
  87:steering.c    **** }
 326               		.loc 1 87 0
 327 0126 DF91      		pop r29
 328 0128 CF91      		pop r28
 329               	.LVL39:
 330 012a 1F91      		pop r17
 331 012c 0F91      		pop r16
 332 012e FF90      		pop r15
 333 0130 EF90      		pop r14
 334 0132 DF90      		pop r13
 335 0134 CF90      		pop r12
 336 0136 0895      		ret
 337               		.cfi_endproc
 338               	.LFE3:
 340               	.Letext0:
 341               		.file 2 "/usr/lib/avr/include/stdint.h"
 342               		.file 3 "cmod.h"
 343               		.file 4 "timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 steering.c
     /tmp/ccjdvBDr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccjdvBDr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccjdvBDr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccjdvBDr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccjdvBDr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccjdvBDr.s:12     .text:0000000000000000 drive
     /tmp/ccjdvBDr.s:65     .text:0000000000000028 stop
     /tmp/ccjdvBDr.s:83     .text:0000000000000030 turn
     /tmp/ccjdvBDr.s:212    .text:00000000000000a2 pentagon

UNDEFINED SYMBOLS
byteTx
delayMs
__floatsisf
__mulsf3
__divsf3
__fixsfsi
